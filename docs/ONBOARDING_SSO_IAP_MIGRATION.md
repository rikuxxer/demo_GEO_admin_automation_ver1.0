# 貴社環境移行時の確認事項（権限・SSO/IAP）

**対象読者:** 移行先会社のインフラ・セキュリティ担当  
**目的:** 権限の振り分けの有無と、SSO（IAP）実装に必要な情報を先んじて共有する  
**最終更新:** 2026年2月7日

---

## 採用方針（2026年2月）

- **IAP の認証結果をアプリ側で利用する**  
  IAP が付与するユーザー識別情報（ヘッダー等）をアプリで受け取り、BigQuery の `users` と紐付けてロールを取得し、セッションを確立する。
- **ログイン画面は Google 認証のみで検討**  
  メール＋パスワードは廃止し、Google 認証（IAP で Google を IdP にした場合の IAP 経由、またはアプリ上の「Google でログイン」）のみとする。

---

## 1. 権限の振り分けについて

**はい、権限の振り分けを想定した設計になっています。**

### 1.1 ロール定義（2ロール）

| ロールID | 表示名 | 想定ユーザー |
|----------|--------|----------------|
| **admin** | 管理者 | 管理部門スタッフ |
| **sales** | 営業 | 営業担当者 |

- ユーザーは BigQuery の `users` テーブルで管理され、`role` に `admin` または `sales` が格納されます。
- ユーザー登録申請（`user_requests`）では `requested_role` で希望ロールを申請し、管理者が承認すると `users.role` が設定されます。

### 1.2 権限マトリックス（概要）

- **管理者（admin）**: 全案件閲覧・ステータス変更・ユーザー管理・編集リクエスト承認・削除など、ほぼ全機能にアクセス可能。
- **営業（sales）**: 案件・セグメント・地点の作成・編集、自分の担当案件の管理、編集リクエストの作成・取り下げ。他営業の進行中案件は閲覧不可（連携完了案件のみ閲覧可）。

詳細は **`docs/security/AUTHORIZATION_SPECIFICATION.md`**（権限マトリックス・データアクセス制御）を参照してください。

### 1.3 実装上の権限定義

- **フロントエンド:** `src/types/auth.ts` の `ROLE_PERMISSIONS` でロールごとの権限フラグを定義。
- **判定:** `hasPermission('canViewAdminDashboard')` 等でUI表示・操作を制御。データレベルでは `canViewProject` / `canEditProject`（`src/utils/editRequest.ts`）で案件単位の閲覧・編集可否を判定しています。
- **バックエンド:** 現状、API では呼び出し元のユーザー/ロールを検証する共通ミドルウェアはありません。権限による制御は主にフロントエンドと BigQuery のデータ（担当者情報など）に依存しています。

---

## 2. 現在の認証方式（SSO 未実装）

アプリケーション側では **SSO は未実装** です。

### 2.1 認証フロー（現状）

```
[ユーザー] → [ログイン画面] → [メール + パスワード] → [BigQuery users 照合] → [セッション確立] → [権限チェック]
```

- **認証:** メールアドレス + パスワード。BigQuery の `users` テーブルで照合し、一致かつ `is_active` の場合にログイン成功。
- **セッション:** ブラウザの **LocalStorage** に `currentUser`（id, name, email, role, department）を保存。ログアウトまで有効。
- **パスワード:** 本番では適切なハッシュ化（bcrypt 等）への移行が推奨されています（仕様書に記載）。

### 2.2 バックエンドAPIの認証

- バックエンドは **Authorization ヘッダー等で呼び出し元ユーザーを検証していません**。
- フロントエンドがログイン済みユーザー情報に基づいて API を呼び出し、業務ロジック上の制限（担当案件のみ等）は主にフロントとデータで担保している状態です。

---

## 3. 貴社での SSO（IAP）導入との関係

貴社で予定されている作業は以下の理解です。

1. ロードバランサー（CLB）をアプリの全段に配置  
2. ロードバランサ内で IAP（Identity-Aware Proxy）を有効化  
3. SSL/TLS 証明書を発行（ドメイン名設定が必要）  
4. 証明書をロードバランサに登録  
5. IAP で SSO を実装  
6. インフラ側で DNS 等を操作  

### 3.1 アプリ側で現時点までに分かっている「SSO 実装の詳細」

- **アプリケーション内に IAP / OAuth / SAML / OIDC の実装はありません。**  
  すべて「メール + パスワード ＋ BigQuery の users テーブル」による認証です。
- **権限（振り分け）はロール（admin/sales）とデータ単位（担当者）で実装済み**です。IAP 導入後も、**「誰がログインしているか」をアプリが知る仕組み」** をどうするかが連携のポイントになります。

### 3.2 採用方針: IAP 認証結果の利用 ＋ ログインは Google 認証のみ

- **IAP の認証結果をアプリで利用する**  
  IAP が検証したユーザー識別子（Google 認証で得たメール等）をリクエストヘッダー（例: `X-Goog-Authenticated-User-Email`）で渡し、アプリ側でそのメールを BigQuery の `users` と照合してロールを取得し、セッションを確立する。
- **ログインは Google 認証のみ**  
  メール＋パスワードは廃止し、次のいずれかまたは組み合わせで検討する。
  - **パターン A（IAP で Google を IdP）:** ユーザーは IAP の Google サインインのみ行い、通過後はアプリにログイン画面は出さない。アプリはバックエンド経由で IAP ヘッダーから「現在のユーザー」を取得する。
  - **パターン B（アプリで「Google でログイン」）:** IAP の前段や開発時など、ログイン画面を出す場合は「Google でログイン」ボタンのみとし、Google OAuth で得たメールで BigQuery `users` を検索してロールを設定する。

**共通で必要なこと**

- BigQuery の `users` テーブルに **登録済みメールアドレス** が、Google 認証で得られるメールと一致していること（大文字小文字・前後の空白の扱いを統一）。
- 未登録の Google アカウントでアクセスした場合は「未登録ユーザー」としてエラーまたは申請フローへ誘導する運用を検討する。

### 3.3 ドメイン・DNS・SSL について

- アプリは **ドメインに依存したハードコードは最小限** です（例: パスワードリセットのリンクなどで環境変数 `VITE_APP_URL` 等を利用想定）。  
- **ドメイン名の決定後**に、必要に応じて環境変数や設定を差し替えれば対応可能です。  
- SSL/TLS はロードバランサで終端する想定で問題なく、アプリ側の特別な対応は通常不要です。

### 3.4 バックエンド（Cloud Run 等）の位置づけ

- フロントはブラウザから **バックエンド API（Cloud Run の URL 等）** を呼び出します。  
- 貴社構成では、**CLB → IAP → バックエンド** とする場合、**バックエンドへのリクエストに IAP が付与するヘッダー**（ユーザー識別子など）を、今後の「SSO 連携」で利用するかどうかを決める必要があります。  
- 現状のバックエンドは「ユーザー/ロール」をヘッダーで見ていないため、**オプション B を採る場合はバックエンド側で「IAP 由来のヘッダーを信頼し、ユーザー・ロールを渡す/検証する」実装の追加**が必要になります。

---

## 4. 先んじて共有できる「実装の詳細」一覧

| 項目 | 内容・参照先 |
|------|------------------|
| 権限の振り分け | 想定済み。ロール: admin / sales。`docs/security/AUTHORIZATION_SPECIFICATION.md` |
| 権限マトリックス | 上記仕様書「権限マトリックス」「データアクセス制御」 |
| 認証方式（現状） | メール + パスワード、BigQuery `users` 照合、LocalStorage セッション |
| SSO / ログイン方針 | **採用方針:** IAP の認証結果をアプリで利用。ログインは **Google 認証のみ**（メール＋パスワード廃止）。 |
| IAP 連携 | 実装予定。IAP ヘッダーからユーザー識別 → BigQuery `users` でロール取得。「現在ユーザー取得 API」をバックエンドに新設。 |
| Google 認証のみ | ログイン画面は「Google でログイン」のみ。Firebase Auth または Google Identity Services で実装。 |
| ドメイン/DNS | ドメイン決定後に環境変数等で設定可能。アプリはドメイン直書きは最小限 |
| SSL/TLS | LB 終端で問題なし。アプリ側の特別対応は想定していない |
| バックエンド認証 | 現状は API でユーザー/ロール未検証。IAP 連携時はヘッダー利用の拡張が必要になり得る |

---

## 5. 実装の方向性（IAP 認証結果の利用 ＋ Google 認証のみ）

### 5.1 IAP の認証結果をアプリで使う場合

| 項目 | 内容 |
|------|------|
| **ヘッダー** | IAP がバックエンドに付与するヘッダーを利用する。例: `X-Goog-Authenticated-User-Email`（値は `accounts.google.com:メールアドレス` 等形式のため、プレフィックス除去が必要な場合あり）。 |
| **バックエンド** | リクエストから IAP 由来ヘッダーを読み、メールを正規化して BigQuery `users` を検索。取得した user_id, name, email, role を JSON で返す「現在ユーザー取得 API」を新設する。 |
| **フロントエンド** | 初回表示時または定期的に上記 API を呼び、返却されたユーザーで `AuthContext` の `user` を設定。ログイン画面は表示しない（パターン A）。 |
| **信頼の前提** | バックエンドは IAP の背後でのみ公開し、IAP を通さない直接アクセスではこの API を呼べないようにする。 |

### 5.2 ログイン画面を Google 認証のみにする場合

| 項目 | 内容 |
|------|------|
| **廃止するもの** | メール＋パスワードの入力フォーム。デモ用の固定パスワード認証。 |
| **追加するもの** | 「Google でログイン」のみのログイン画面。Google 認証は次のいずれかで実装可能。 |
| **実装候補** | **Firebase Authentication（Google プロバイダ）** または **Google Identity Services（GIS）**。いずれも OAuth 2.0 で Google からメール・表示名を取得し、そのメールで BigQuery `users` を検索してロールを決定する。 |
| **変更箇所** | `src/components/Login.tsx` を「Google でログイン」ボタンのみの UI に変更。`src/contexts/AuthContext.tsx` の `login` を `loginWithGoogle(idToken または accessToken)` 等に拡張し、トークン検証または Google のユーザー情報取得後に BigQuery でユーザー・ロールを取得してセッションを張る。 |

### 5.3 組み合わせ例

- **本番（IAP 有効）:** パターン A。IAP で Google 認証 → バックエンドが IAP ヘッダーからユーザー取得 → フロントは「現在ユーザー取得 API」を呼んでセッション確立。ログイン画面なし。
- **開発・検証（IAP なし）:** パターン B。ログイン画面で「Google でログイン」のみ表示し、Google 認証後に BigQuery でロール取得。同一の `AuthContext` と権限ロジックを利用。

---

## 6. 次のステップの提案

1. **IAP のヘッダー名・値の形式**（例: `X-Goog-Authenticated-User-Email` の実際の値）を共有いただければ、バックエンドの「現在ユーザー取得 API」仕様とフロントの呼び出し仕様を具体化します。  
2. **Google 認証のみのログイン画面**は、Firebase Auth と GIS のどちらを採用するか決めていただければ、`Login.tsx` / `AuthContext.tsx` の変更案を提示します。  
3. 権限の追加ロールや、より細かい権限の振り分けが必要な場合は、`ROLE_PERMISSIONS` と `AUTHORIZATION_SPECIFICATION.md` をベースに拡張可能です。

---

## 7. 次に必要な情報（実装を進めるために共有いただきたいもの）

実装を具体化するために、以下の情報があると助かります。

| # | 必要な情報 | 用途 | 共有可能なタイミング |
|---|------------|------|----------------------|
| 1 | **IAP がバックエンドに付与するヘッダー名** | 例: `X-Goog-Authenticated-User-Email`。バックエンドで「現在ユーザー取得 API」がどのヘッダーを読むか決めるため。 | IAP 有効化後、または GCP ドキュメント・構成案が固まった時点 |
| 2 | **ヘッダーの値の形式** | 例: `accounts.google.com:user@example.com` のようなプレフィックス有無。メールの正規化（トリム・小文字化等）の実装のため。 | 上記と同時 |
| 3 | **Google 認証の実装方針** | 「Google でログイン」を **Firebase Authentication** で行うか、**Google Identity Services（GIS）** で行うか。ログイン画面・AuthContext の変更案を出すため。 | アプリ側の Google ログイン実装に着手する前 |
| 4 | **本番ドメイン名（確定値）** | パスワードリセットやコールバック URL 等で使う環境変数（例: `VITE_APP_URL`）の設定のため。 | DNS・SSL の設定が決まった時点 |
| 5 | **フロント／バックエンドの公開先** | フロントとバックエンドを同一ドメインで提供するか、サブドメインやパスで分けるか。CORS と IAP の適用範囲を決めるため。 | LB・IAP の構成設計時 |

**最小限で着手できるもの**

- **1・2** が分かれば、バックエンドの「現在ユーザー取得 API」とフロントの IAP 連携の仕様を具体化できます。  
- **3** が決まれば、ログイン画面を Google 認証のみにする変更案（`Login.tsx` / `AuthContext.tsx`）を提示できます。

### 情報が揃ったら稼働するか・テストできるか

**いいえ。** 上記の情報が全て揃っても、その時点ではまだ**稼働する状態にはなっていません**。

- 情報は「実装の仕様を決めるための入力」です。  
- 情報を元に **バックエンドの「現在ユーザー取得 API」の実装** と **フロントの IAP 連携・Google ログインへの差し替え** を行う必要があります。  
- **実装が完了し、デプロイした後**にはじめて本番相当の稼働状態になり、テスト可能になります。

**流れのイメージ**

1. 必要な情報（1〜5）を共有いただく  
2. 仕様を具体化し、実装（コード変更）を行う  
3. デプロイして動作確認・テスト  
4. 問題なければ稼働

テストは **実装・デプロイ後のステップ 3** で行う形になります。情報共有は後からで問題ありません。

---

**参照ドキュメント**

- 権限・認証の詳細: `docs/security/AUTHORIZATION_SPECIFICATION.md`
- ロール・権限定義（コード）: `src/types/auth.ts`
- データアクセス制御: `src/utils/editRequest.ts`（`canViewProject`, `canEditProject` 等）
